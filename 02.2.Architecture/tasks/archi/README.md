# Architecture


![img.png](img.png)

В этом домашнем задании мы с вами познакомимся с приколами питона во время написания проектов.
И так, вы проделали хорошую работу по написанию первой части домашки: вы накидали небольшую кодовую базу. По сути сделали MVP проекта. 
На этом этапе, всегда можно было делать что захочешь. Но теперь мы на таком этапе где уже этого делать нельзя.

Что нужно вам тут сделать: (разобью задачу на этапы)


### Этап №0

1. Cпуллить изменение, критерий что все ок: увидеть это условие у себя на компе

необходимо прожать в репозитории кнопочку Fork, после локально сделать ``git pull . ``

2. Счекаутиться на новую ветку которую необходимо назвать в честь своего логина на гитлабе https://git-scm.com/

```
git status
git checkout -b <ваш_логин>
```

### Этап №1 

Вам необходимо скопировать проект в новую папку "руками git'a"


Как это сделать?

Cтатья для изучения: https://git-scm.com/docs/git-mv (git mv)

Этот этап блокирующий. При ревью если мы заметим что файлы скопированы руками, отправим переделывать. В случае если вы вообще это не сделаете. Проверка закончится выставится в итог 100 баллов.

### Этап №2 (самый большой)

Сейчас ваш код разбросан по модулям `cli.py` `model.py` -- тут необходимо понять. Кто где должен жить. 

У вас в файловой системе проекта уже есть один большущий пакет `logscoper`. Сейчас все запчасти проекта лежат в одном месте -- плохая идея. Мы не понимаем кто за что отвечает. 


В чистой архитектуре принято разделять код на слои -- каждый слой отвечает только за своё и не лезет в чужую зону ответственности.

#### Примерное разделение

1. Domain (домен) - предметная область

Здесь все самое чистое. Тут как раз должен поселиться ваш `LogEntry` (как пример), вычисления, фильтры, статистика. **Те что не зависят от других слоев.**

2. Use Cases (сценарии)

Сценарии описывают что делает приложение:
* посчитать статистику
* отфильтровать логи
* нарисовать гистограму

3. Адаптеры

Тут строится связь между пользователем и вашем приложением и логикой. Как на вход так и на выход. 
К примеру:
* данные, которые попадают на вход
* данные, которые должны вернуться на выход

Здесь должно оказаться все то что превращается в то, что становится понятной предметной области.

4. Инфраструктура
Всё, что связано с окружением и запуском приложения.

Консольный интерфейс, точка входа, работа с файлами, стандартным выводом/ошибками.

Этот слой «собирает» всё приложение и связывает остальные слои.


### Ваша задача

**Что у вас сейчас:** Один пакет `logscoper`'a который включает в себя салат из разных функций

**Что должно получиться:** Пакет `logscoper`'а в  котором будут жить другие пакеты, описанные по зоне ответственности выше.

**Ожидается**, что у вас появится пакеты в корне `logscoper`'а:

- commands - сценарии: `stats`, `filter`, `hist`
- models - предметная область: сущности, фильтры, вычисления, статистика.
- adapters - адаптеры: парсинг входных данных, преобразование результатов JSON в текст и обратно
- infra - инфраструктура: CLI, точка входа и т.д.


Что должно быть (см.картинку -- граф зависимостей):
* `models` **НЕ ЗАВИСИТ** от адаптеров, инфраструктуры, библиотек ввода/вывода.
* `commands` зависят только от Domain.
* `adapters` знает только о `models` и `commands` но в `infra` не лезут
* `infra` собирает все классы и только она вызывает соответствующие библиотеки -- `argparse`, `sys`, `pathlib` и тд.


**Этап №3**

**Типизации**. Необходимо пройтись по всему коду и поправить на верную типизацию. Если вы считаете что `mypy` вас задушил, то проставьте над проблемной строчкой, `#type: ignore`. Если мы заметим, что вы это сделали просто не раздумывая, оставим `issue` на доработку.


**Этап №4**

Необходимо чтобы ваша реализация не сломалась на этапе тестов. Необходимо добиться `TESTS PASSED` в логах CI. Сделать Merge Request вашей реализации. Ccылку на MR скинуть в чат вашей группы. Семинарист или ассистент его будут смотреть.
